{"version":3,"file":"index.js","sources":["../../../src/generators/sync-project-types/index.ts"],"sourcesContent":["/**\n * @file Generator for syncing project types across all projects.\n *\n * This generator automatically applies project types to projects based on their tags.\n */\n\nimport { Tree, formatFiles, getProjects, logger } from \"@nx/devkit\";\nimport { SyncProjectTypesGeneratorSchema } from \"./schema\";\nimport { discoverProjectTypes, matchProjectType } from \"../../lib/project-type-utils\";\n\n/**\n * Main generator function for syncing project types across all projects.\n * @param tree - The Nx file tree.\n * @param options - The generator options.\n * @returns A function to run after generation (can be empty).\n * @example\n * // Will be called by Nx when running the generator\n * await syncProjectTypesGenerator(tree, { dryRun: false });\n */\nexport default async function syncProjectTypesGenerator(\n  tree: Tree,\n  options: SyncProjectTypesGeneratorSchema\n): Promise<() => void> {\n  const { dryRun } = options;\n\n  // Discover all project types\n  const projectTypes = discoverProjectTypes(tree);\n  logger.info(`Discovered ${projectTypes.length} project types`);\n\n  // Get all projects\n  const projects = getProjects(tree);\n  logger.info(`Found ${projects.size} projects`);\n\n  // For each project, find the matching project type\n  let matchCount = 0;\n\n  for (const [projectName, projectConfig] of projects.entries()) {\n    const projectTags = projectConfig.tags || [];\n\n    // Skip projects without tags\n    if (projectTags.length === 0) {\n      logger.info(`Skipping project ${projectName} (no tags)`);\n      continue;\n    }\n\n    // Find matching project type\n    const matchedType = matchProjectType(projectTags, projectTypes);\n\n    if (matchedType) {\n      matchCount++;\n      logger.info(\n        `${dryRun ? \"[DRY RUN] Would match\" : \"Matched\"} project ${projectName} to type ${matchedType.name}`\n      );\n    }\n  }\n\n  logger.info(`${dryRun ? \"Would match\" : \"Matched\"} ${matchCount} projects to project types`);\n\n  // Format files (standard practice for generators)\n  await formatFiles(tree);\n\n  // Return a function to run after generation\n  return () => {\n    logger.info(`Successfully ${dryRun ? \"simulated sync of\" : \"synced\"} project types`);\n  };\n}\n"],"names":["discoverProjectTypes","logger","getProjects","matchProjectType","formatFiles"],"mappings":";;;;;;;AAAA;;;;AAIG;AAMH;;;;;;;;AAQG;AACY,eAAe,yBAAyB,CACrD,IAAU,EACV,OAAwC,EAAA;AAExC,IAAA,MAAM,EAAE,MAAM,EAAE,GAAG,OAAO;;AAG1B,IAAA,MAAM,YAAY,GAAGA,yCAAoB,CAAC,IAAI,CAAC;IAC/CC,aAAM,CAAC,IAAI,CAAC,CAAA,WAAA,EAAc,YAAY,CAAC,MAAM,CAAgB,cAAA,CAAA,CAAC;;AAG9D,IAAA,MAAM,QAAQ,GAAGC,kBAAW,CAAC,IAAI,CAAC;IAClCD,aAAM,CAAC,IAAI,CAAC,CAAA,MAAA,EAAS,QAAQ,CAAC,IAAI,CAAW,SAAA,CAAA,CAAC;;IAG9C,IAAI,UAAU,GAAG,CAAC;AAElB,IAAA,KAAK,MAAM,CAAC,WAAW,EAAE,aAAa,CAAC,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE;AAC7D,QAAA,MAAM,WAAW,GAAG,aAAa,CAAC,IAAI,IAAI,EAAE;;AAG5C,QAAA,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;AAC5B,YAAAA,aAAM,CAAC,IAAI,CAAC,oBAAoB,WAAW,CAAA,UAAA,CAAY,CAAC;YACxD;;;QAIF,MAAM,WAAW,GAAGE,qCAAgB,CAAC,WAAW,EAAE,YAAY,CAAC;QAE/D,IAAI,WAAW,EAAE;AACf,YAAA,UAAU,EAAE;YACZF,aAAM,CAAC,IAAI,CACT,CAAA,EAAG,MAAM,GAAG,uBAAuB,GAAG,SAAS,YAAY,WAAW,CAAA,SAAA,EAAY,WAAW,CAAC,IAAI,CAAE,CAAA,CACrG;;;AAIL,IAAAA,aAAM,CAAC,IAAI,CAAC,CAAG,EAAA,MAAM,GAAG,aAAa,GAAG,SAAS,IAAI,UAAU,CAAA,0BAAA,CAA4B,CAAC;;AAG5F,IAAA,MAAMG,kBAAW,CAAC,IAAI,CAAC;;AAGvB,IAAA,OAAO,MAAK;AACV,QAAAH,aAAM,CAAC,IAAI,CAAC,CAAA,aAAA,EAAgB,MAAM,GAAG,mBAAmB,GAAG,QAAQ,CAAA,cAAA,CAAgB,CAAC;AACtF,KAAC;AACH;;;;"}